<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>庸人妄语</title>
    <link>https://mandydragon.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 17 Nov 2017 10:00:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>php魔术方法</title>
      <link>https://mandydragon.github.io/2017/11/17/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</link>
      <guid>https://mandydragon.github.io/2017/11/17/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Fri, 17 Nov 2017 08:24:54 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;PHP魔术方法&quot;&gt;&lt;a href=&quot;#PHP魔术方法&quot; class=&quot;headerlink&quot; title=&quot;PHP魔术方法&quot;&gt;&lt;/a&gt;PHP魔术方法&lt;/h1&gt;&lt;p&gt;PHP 将所有以 &lt;em&gt; &lt;/em&gt;开头的类法保 为魔术方法。所以在定义类方法时，除了上述魔术方法
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="PHP魔术方法"><a href="#PHP魔术方法" class="headerlink" title="PHP魔术方法"></a>PHP魔术方法</h1><p>PHP 将所有以 <em> </em>开头的类法保 为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 <em> </em> 为前缀</p><h2 id="一、方法简介"><a href="#一、方法简介" class="headerlink" title="一、方法简介"></a>一、方法简介</h2><ol><li><p>__construct()，类的构造函数，在同一个类中只能声明一个构造方法</p><pre><code>php不支持重载，如需要父类的构造函数需显式调用</code></pre></li><li>__destruct()，类的析构函数，析构方法允许在销毁整个类之前执行的某些操作，无参数</li><li><p><strong>call()、</strong>callStatic()，方法重载，调用未定义过的(静态)方法时被调用</p><pre><code>可以使用__call进行友善的错误处理，避免当调用不存在的方法时产生错误，意外的导致程序中止</code></pre></li><li><p>属性重载</p><pre><code>public void __set ( string $name , mixed $value )public mixed __get ( string $name )public bool __isset ( string $name )public void __unset ( string $name )</code></pre></li><li><p>__clone()复制时调用，复制时引用复制（浅复制），结合clone关键字实现真正的复制</p></li><li><p><strong>autoload()作用: 是当你调用不存在的类时会被动调用，不建议使用，原因:</strong>autoload()重复定义时，冲突报错，只能有一个__autoload()函数，</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function __autoload($class)&#123;    if(file_exists($class.&quot;.php&quot;))&#123;        require_once($class.&quot;.php&quot;);    &#125; else &#123;        die(&quot; 件 存在!&quot;);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p> 推荐使用spl_autoload_register()</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function my_autoload1($class)&#123;    if(file_exists(&quot;classes/&quot;.$class.&quot;.php&quot;))&#123;        require_once(&quot;classes/&quot;.$class.&quot;.php&quot;);    &#125; else &#123; </span><br><span class="line">        die(&quot; 件 存在!&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">function my_autoload2($class)&#123;    if(file_exists(&quot;core/&quot;.$class.&quot;.php&quot;))&#123;        require_once(&quot;core/&quot;.$class.&quot;.php&quot;);    &#125;else&#123;        die(&quot; 件 存在!&quot;); </span><br><span class="line">    &#125;&#125;</span><br><span class="line">//将加载函数注册到PHP中</span><br><span class="line">spl_autoload_register(&quot;my_autoload1&quot;);</span><br><span class="line">spl_autoload_register(&quot;my_autoload2&quot;);</span><br></pre></td></tr></table></figure></li><li><p>__sleep()在对一个对象序列化时(调用serialize()时)会被调用。它不接收任何参数，而且应该返回一个包含所有应该被序列化的属性的数组;</p></li><li>__wakeup()在对存储的对象反序列化时会被调用;</li><li>__toString() :在我们将对象当作字符串一样使用时会被调用;</li><li>__set_state:使用var_export()函数输出对象时会调用该方法</li><li>__debugInfo(): 打印调试信息时调用</li><li>__invoke() :使用调用函数的方式调一个对象时调用该函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person &#123;     public $sex;     public $name;     public $age;</span><br><span class="line">         public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)&#123;         $this-&gt;name = $name;         $this-&gt;age  = $age;         $this-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line">        public function __invoke() &#123; </span><br><span class="line">    echo &apos;这是 个对象&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  $person = new Person(&apos;jack&apos;); $person();</span><br></pre></td></tr></table></figure><h2 id="二、-AOP在PHP中的实现"><a href="#二、-AOP在PHP中的实现" class="headerlink" title="二、 AOP在PHP中的实现 :"></a>二、 AOP在PHP中的实现 :</h2><p>&emsp;&emsp;在传统的OOP(面向对象编程:Object-Oriented Programming)思想 ，一般把应用程序分解成若干个对象，强调<code>高内聚</code>，<code>弱耦合</code>，从而提高应用程序的模块化程度，但是在处理某些问题的时候，OOP会显得不够灵活,比如说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用程序很多业务逻辑都要在操作之初进 “权限检查”，在操作之后进行“日志记录”，如果直接把处理逻辑直接加到</span><br><span class="line">每个模块中，那么无疑破坏了OOP的“单一职责”原则，模块的可重用就会大大降低，这时候传统的OOP设计往往采取的策</span><br><span class="line">略是加如相应的代理(Proxy)层来完成系统的功能要求，但这样的处理明显使系统整体增加一个层次的划分，复杂性也随</span><br><span class="line">之增加，从而给人过于厚重的感觉。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;正是为了处理这样的问题，<code>AOP</code>(面向切面编程:Aspect-Oriented Programming)思想应运而生，假设把应用程序想成一个立体结构的话，OOP的刃是<code>纵向</code>切入系统，把系统划分为很多个模块(如:用户模块，文章模块等)， AOP的刀刃是横向切分系统，提取各个模块可能都要重复操作的部分(如:权限检查，日志记录等等)。由此可见，AOP是OOP的一个有效补充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就目前的PHP来说，还没有一个完整的AOP内置实现，虽然出现 RunKit，但估计很长时间内不太可能成为PHP的缺省设置。</span><br><span class="line">那是么是AOP在PHP可以实现吗?当然，因为我们有get()，set()，__call()等魔术方法，结合起来使用这些方法可以为</span><br><span class="line">我们实现某种程度的“准AOP”，之所以说是准AOP，是因为单单从实现上来看，称其为AOP有些牵强，但是从效果上来看，</span><br><span class="line">又部分实现  AOP的作用，虽然其实现方式并不完美，但对于一般的使用已经够了。</span><br></pre></td></tr></table></figure><h2 id="三、魔术变量"><a href="#三、魔术变量" class="headerlink" title="三、魔术变量"></a>三、魔术变量</h2><ol><li>LINE: 文件中的当前行号。</li><li>FILE: 文件的完整路径和文件名。当在被包含文件中，则返回被包含的文件名</li><li>DIR: 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</li><li>FUNCTION: 常量，返回该函数被定义时的名字</li><li>CLASS: 常量，返回该类被定义时的名字(区分大小写)。</li><li>METHOD:返回该方法被定义时的名字(区分大小写)。<br>7.NAMESPACE:当前命名空间的名称(区分大小写)</li></ol><h2 id="四、超全局变量"><a href="#四、超全局变量" class="headerlink" title="四、超全局变量"></a>四、超全局变量</h2><ol><li>$GLOBALS:储存全局作用域中的变量。</li><li>$_SERVER:获取服务器相关信息。</li><li>$_REQUEST:获取POST和GET请求的参数</li><li>$_POST:获取表单的POST请求参数 </li><li>$_GET:获取表单的GET请求参数</li><li>$_FILES:获取上传文件的的变量</li><li>$_ENV:获取服务器端环境变量的数组</li><li>$_COOKIE:浏览器cookie的操作</li><li>$_SESSION:服务端session的操作</li></ol><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>&emsp;&emsp;PHP中的”重载”与其它绝大多数面向对象语言不同。传统的”重载”是提供多个同名的类方法，但各方法的参数类型和个数不同。 PHP所提供的”重载”(overloading)是指动态地”创建”类属性和方法。 当调用当前环境下未定义或 不可见的类属性或方法时，重载方法会被调用</p><hr>]]></content:encoded>
      
      <comments>https://mandydragon.github.io/2017/11/17/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Centos安装php7</title>
      <link>https://mandydragon.github.io/2017/11/16/Centos7%E5%AE%89%E8%A3%85php7/</link>
      <guid>https://mandydragon.github.io/2017/11/16/Centos7%E5%AE%89%E8%A3%85php7/</guid>
      <pubDate>Thu, 16 Nov 2017 09:10:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;#php7 yum安装&lt;/p&gt;
&lt;p&gt;##哈哈哈哈&lt;br&gt;&lt;em&gt;加载&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
        
      
      </description>
      
      <content:encoded><![CDATA[<p>#php7 yum安装</p><p>##哈哈哈哈<br><em>加载</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello word</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mandydragon.github.io/2017/11/16/Centos7%E5%AE%89%E8%A3%85php7/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
