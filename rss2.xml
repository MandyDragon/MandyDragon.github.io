<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>庸人妄语</title>
    <link>https://mandydragon.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 17 Nov 2017 11:51:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>php魔术方法</title>
      <link>https://mandydragon.github.io/2017/11/17/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</link>
      <guid>https://mandydragon.github.io/2017/11/17/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Fri, 17 Nov 2017 08:24:54 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;PHP 将所有以 &lt;em&gt; &lt;/em&gt;开头的类法保 为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 &lt;em&gt; &lt;/em&gt; 为前缀&lt;/p&gt;
&lt;h1 id=&quot;一、方法简介&quot;&gt;&lt;a href=&quot;#一、方法简介&quot; class=&quot;headerlink&quot; title=&quot;一
        
      
      </description>
      
      <content:encoded><![CDATA[<p>PHP 将所有以 <em> </em>开头的类法保 为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 <em> </em> 为前缀</p><h1 id="一、方法简介"><a href="#一、方法简介" class="headerlink" title="一、方法简介"></a>一、方法简介</h1><ul><li><p>__construct()，类的构造函数，在同一个类中只能声明一个构造方法</p><pre><code>php不支持重载，如需要父类的构造函数需显式调用</code></pre></li><li>__destruct()，类的析构函数，析构方法允许在销毁整个类之前执行的某些操作，无参数</li><li><strong>call()、</strong>callStatic()，方法重载，调用未定义过的(静态)方法时被调用,可以使用__call进行友善的<code>错误处理</code>，避免当调用不存在的方法时产生错误，意外的导致程序中止</li><li>属性重载</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">public</span> void __set ( string $name , mixed $value )<span class="keyword">public</span> mixed __get ( string $name )<span class="keyword">public</span> bool __isset ( string $name )<span class="keyword">public</span> void __unset ( string $name )</span><br></pre></td></tr></table></figure><ul><li>__clone()复制时调用，复制时引用复制（浅复制），结合clone关键字实现真正的复制</li><li><strong>autoload()作用: 是当你调用不存在的类时会被动调用，不建议使用，原因:</strong>autoload()重复定义时，冲突报错，只能有一个__autoload()函数</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class)</span></span>&#123;   <span class="keyword">if</span>(file_exists($class.<span class="string">".php"</span>))&#123;            <span class="keyword">require_once</span>($class.<span class="string">".php"</span>);   &#125; <span class="keyword">else</span> &#123;       <span class="keyword">die</span>(<span class="string">"文件不存在!"</span>);</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure><p>推荐使用spl_autoload_register()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_autoload1</span><span class="params">($class)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(file_exists(<span class="string">"classes/"</span>.$class.<span class="string">".php"</span>))&#123;</span><br><span class="line">      <span class="keyword">require_once</span>(<span class="string">"classes/"</span>.$class.<span class="string">".php"</span>);        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">die</span>(<span class="string">"文件不存在!"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">my_autoload2</span><span class="params">($class)</span></span>&#123;        <span class="keyword">if</span>(file_exists(<span class="string">"core/"</span>.$class.<span class="string">".php"</span>))&#123;            <span class="keyword">require_once</span>(<span class="string">"core/"</span>.$class.<span class="string">".php"</span>);        &#125;<span class="keyword">else</span>&#123;            <span class="keyword">die</span>(<span class="string">"文件不存在!"</span>); </span><br><span class="line">  &#125;&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//将加载函数注册到PHP中</span></span><br><span class="line">spl_autoload_register(<span class="string">"my_autoload1"</span>);</span><br><span class="line">spl_autoload_register(<span class="string">"my_autoload2"</span>);</span><br></pre></td></tr></table></figure><ul><li>__sleep()在对一个对象序列化时(调用serialize()时)会被调用。它不接收任何参数，而且应该返回一个包含所有应该被序列化的属性的数组;</li><li>__wakeup()在对存储的对象反序列化时会被调用;</li><li>__toString() :在我们将对象当作字符串一样使用时会被调用;</li><li>__set_state:使用var_export()函数输出对象时会调用该方法</li><li>__debugInfo(): 打印调试信息时调用</li><li>__invoke() :使用调用函数的方式调一个对象时调用该函数</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $sex;    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name=<span class="string">""</span>, $age=<span class="number">25</span>, $sex=<span class="string">'男'</span>)</span></span>&#123;         <span class="keyword">$this</span>-&gt;name = $name;         <span class="keyword">$this</span>-&gt;age  = $age;         <span class="keyword">$this</span>-&gt;sex  = $sex;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'这是 个对象'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> $person = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);$person();</span><br></pre></td></tr></table></figure><h1 id="二、-AOP在PHP中的实现"><a href="#二、-AOP在PHP中的实现" class="headerlink" title="二、 AOP在PHP中的实现 :"></a>二、 AOP在PHP中的实现 :</h1><p>&emsp;&emsp;在传统的OOP(面向对象编程:Object-Oriented Programming)思想 ，一般把应用程序分解成若干个对象，强调<code>高内聚</code>，<code>弱耦合</code>，从而提高应用程序的模块化程度，但是在处理某些问题的时候，OOP会显得不够灵活,比如说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用程序很多业务逻辑都要在操作之初进 “权限检查”，在操作之后进行“日志记录”，如果直接把处理逻辑直接加到</span><br><span class="line">每个模块中，那么无疑破坏了OOP的“单一职责”原则，模块的可重用就会大大降低，这时候传统的OOP设计往往采取的策</span><br><span class="line">略是加如相应的代理(Proxy)层来完成系统的功能要求，但这样的处理明显使系统整体增加一个层次的划分，复杂性也随</span><br><span class="line">之增加，从而给人过于厚重的感觉。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;正是为了处理这样的问题，<code>AOP</code>(面向切面编程:Aspect-Oriented Programming)思想应运而生，假设把应用程序想成一个立体结构的话，OOP的刃是<code>纵向</code>切入系统，把系统划分为很多个模块(如:用户模块，文章模块等)， AOP的刀刃是横向切分系统，提取各个模块可能都要重复操作的部分(如:权限检查，日志记录等等)。由此可见，AOP是OOP的一个有效补充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就目前的PHP来说，还没有一个完整的AOP内置实现，虽然出现 RunKit，但估计很长时间内不太可能成为PHP的缺省设置。</span><br><span class="line">那是么是AOP在PHP可以实现吗?当然，因为我们有get()，set()，__call()等魔术方法，结合起来使用这些方法可以为</span><br><span class="line">我们实现某种程度的“准AOP”，之所以说是准AOP，是因为单单从实现上来看，称其为AOP有些牵强，但是从效果上来看，</span><br><span class="line">又部分实现  AOP的作用，虽然其实现方式并不完美，但对于一般的使用已经够了。</span><br></pre></td></tr></table></figure><h1 id="三、魔术变量"><a href="#三、魔术变量" class="headerlink" title="三、魔术变量"></a>三、魔术变量</h1><ol><li>LINE: 文件中的当前行号。</li><li>FILE: 文件的完整路径和文件名。当在被包含文件中，则返回被包含的文件名</li><li>DIR: 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</li><li>FUNCTION: 常量，返回该函数被定义时的名字</li><li>CLASS: 常量，返回该类被定义时的名字(区分大小写)。</li><li>METHOD:返回该方法被定义时的名字(区分大小写)。<br>7.NAMESPACE:当前命名空间的名称(区分大小写)</li></ol><h1 id="四、超全局变量"><a href="#四、超全局变量" class="headerlink" title="四、超全局变量"></a>四、超全局变量</h1><ol><li>$GLOBALS:储存全局作用域中的变量。</li><li>$_SERVER:获取服务器相关信息。</li><li>$_REQUEST:获取POST和GET请求的参数</li><li>$_POST:获取表单的POST请求参数 </li><li>$_GET:获取表单的GET请求参数</li><li>$_FILES:获取上传文件的的变量</li><li>$_ENV:获取服务器端环境变量的数组</li><li>$_COOKIE:浏览器cookie的操作</li><li>$_SESSION:服务端session的操作</li></ol><h1 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h1><p>&emsp;&emsp;PHP中的”重载”与其它绝大多数面向对象语言不同。传统的”重载”是提供多个同名的类方法，但各方法的参数类型和个数不同。 PHP所提供的”重载”(overloading)是指动态地”创建”类属性和方法。 当调用当前环境下未定义或 不可见的类属性或方法时，重载方法会被调用</p><hr>]]></content:encoded>
      
      <comments>https://mandydragon.github.io/2017/11/17/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Centos安装php7</title>
      <link>https://mandydragon.github.io/2017/11/16/Centos7%E5%AE%89%E8%A3%85php7/</link>
      <guid>https://mandydragon.github.io/2017/11/16/Centos7%E5%AE%89%E8%A3%85php7/</guid>
      <pubDate>Thu, 16 Nov 2017 09:10:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;#php7 yum安装&lt;/p&gt;
&lt;p&gt;##哈哈哈哈&lt;br&gt;&lt;em&gt;加载&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
        
      
      </description>
      
      <content:encoded><![CDATA[<p>#php7 yum安装</p><p>##哈哈哈哈<br><em>加载</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello word</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mandydragon.github.io/2017/11/16/Centos7%E5%AE%89%E8%A3%85php7/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
